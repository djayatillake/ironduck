# Test optimizer behavior
# These tests verify that query optimizations produce correct results

# Test constant folding
query I
SELECT 1 + 2 + 3;
----
6

query I
SELECT 10 * 5 - 20;
----
30

query T
SELECT 'hello' || ' ' || 'world';
----
hello world

# Test predicate simplification
query I
SELECT 1 WHERE TRUE AND TRUE;
----
1

query I
SELECT 1 WHERE FALSE OR TRUE;
----
1

# Test filter pushdown with tables
statement ok
CREATE TABLE opt_test (a INTEGER, b INTEGER, c TEXT);

statement ok
INSERT INTO opt_test VALUES (1, 10, 'one'), (2, 20, 'two'), (3, 30, 'three'), (4, 40, 'four'), (5, 50, 'five');

# Filter should be pushed down
query II
SELECT a, b FROM opt_test WHERE a > 2 ORDER BY a;
----
3
30
4
40
5
50

# Multiple filters combined
query II
SELECT a, b FROM opt_test WHERE a > 1 AND b < 50 ORDER BY a;
----
2
20
3
30
4
40

# Test projection pushdown - verify only needed columns are selected
query I
SELECT a FROM opt_test WHERE b > 25 ORDER BY a;
----
3
4
5

# Test limit optimization
query I
SELECT a FROM opt_test ORDER BY a LIMIT 3;
----
1
2
3

query I
SELECT a FROM opt_test ORDER BY a LIMIT 2 OFFSET 2;
----
3
4

# Nested limits - using simple subquery
query I
SELECT a FROM (SELECT 1 as a UNION ALL SELECT 2 UNION ALL SELECT 3) AS sub ORDER BY a LIMIT 2;
----
1
2

# Test with joins
statement ok
CREATE TABLE opt_left (id INTEGER, val TEXT);

statement ok
CREATE TABLE opt_right (id INTEGER, num INTEGER);

statement ok
INSERT INTO opt_left VALUES (1, 'a'), (2, 'b'), (3, 'c');

statement ok
INSERT INTO opt_right VALUES (1, 100), (2, 200), (4, 400);

# Filter on left side of join should be pushed down
query TI
SELECT l.val, r.num FROM opt_left l JOIN opt_right r ON l.id = r.id WHERE l.id > 1 ORDER BY l.id;
----
b
200

# Filter on right side of join
query TI
SELECT l.val, r.num FROM opt_left l JOIN opt_right r ON l.id = r.id WHERE r.num < 300 ORDER BY l.id;
----
a
100
b
200

# Test with subqueries
query I
SELECT a FROM opt_test WHERE a IN (SELECT id FROM opt_left) ORDER BY a;
----
1
2
3

# Test with aggregates - filter before aggregate
query II
SELECT a, AVG(b) FROM opt_test WHERE a > 1 GROUP BY a ORDER BY a;
----
2
20
3
30
4
40
5
50

# Test with CASE expressions
query T
SELECT CASE WHEN a > 3 THEN 'high' ELSE 'low' END FROM opt_test ORDER BY a;
----
low
low
low
high
high

# Test IS NULL optimization
query I
SELECT COUNT(*) FROM opt_test WHERE a IS NOT NULL;
----
5

# Clean up
statement ok
DROP TABLE opt_test;

statement ok
DROP TABLE opt_left;

statement ok
DROP TABLE opt_right;
